// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "../Includes/Utility.hlsl"
#include "../Includes/RandomIsland.hlsl"
#include "../Noise/FastSnoise.hlsl"

int3 dotFieldSize;
float3 origin;
float cellSize;

float scale;
float isoLevel;
float3 randomOffset;

int islandCount;
StructuredBuffer<float4> islandPositions;

RWStructuredBuffer<float4> outputPoints;
RWStructuredBuffer<int> isConcreteFlagBuffer;
RWStructuredBuffer<int> isAirFlagBuffer;

[numthreads(8,8,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    const float3 pos = float3(id) * cellSize+origin;
    float value=SDF_MAX;
    for (int i=0;i<islandCount;i++)
    {
        const float3 islandPos = islandPositions[i].xyz;
        switch (islandPositions[i].w)
        {
        default:
        case 0:
            value = min(value, randomIslandSDFMode1(pos, islandPos, randomOffset));
            break;
        case 1:
            const float3 _pos = sdfRotateAround(pos,
                float3(f_snoise(islandPos),
                    f_snoise(islandPositions[i].xyz+float3(1,0,0)),
                    f_snoise(islandPositions[i].xyz+float3(1,0,1))),
                islandPositions[i].xyz);
            value = min(value, boxSDF(_pos, islandPos, float3(50, 60, 50)));
            break;
        case 2:
                
            value = min(value, basicAstoroidSDF(islandPos,
                float3(id) * cellSize + origin, 60+20*f_snoise(islandPositions[i].xyz), 20,10, randomOffset));
            break;
        }
    }
    
    value = SDFLinearNormalize(value,isoLevel);
    
    outputPoints[GetPointIndex(id.x, id.y, id.z, dotFieldSize)] = float4(float3(id) * cellSize, value);
    if(value< isoLevel)
    {
        InterlockedAdd(isConcreteFlagBuffer[0],-1);
    }
    else
    {
        InterlockedAdd(isAirFlagBuffer[0],-1);
    }
}
