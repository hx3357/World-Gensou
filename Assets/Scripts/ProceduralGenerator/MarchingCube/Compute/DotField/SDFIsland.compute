// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "../Includes/Utility.hlsl"
#include "../Includes/RandomIsland.hlsl"

int3 dotFieldSize;
float3 origin;
float cellSize;

float scale;
float isoLevel;
float3 randomOffset;

int islandCount;
StructuredBuffer<float4> islandPositions;

RWStructuredBuffer<float4> outputPoints;
RWStructuredBuffer<int> isConcreteFlagBuffer;
RWStructuredBuffer<int> isAirFlagBuffer;

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    const float3 pos = float3(id) * cellSize+origin;
    float value=SDF_MAX;
    for (int i=0;i<islandCount;i++)
    {
        const float3 islandPos = islandPositions[i].xyz;
        switch (islandPositions[i].w)
        {
        default:
        case 0:
            value = min(value, randomIslandSDFMode1(pos, islandPos, randomOffset));
            break;
        case 1:
            float3 _pos = sdfRotateAround(pos,
                float3(snoise(islandPos),
                    snoise(islandPositions[i].xyz+float3(1,0,0)),
                    snoise(islandPositions[i].xyz+float3(1,0,1))),
                islandPositions[i].xyz);
            value = min(value, boxSDF(_pos, islandPos, float3(50, 60, 50)));
            break;
        case 2:
            value = min(value, basicAstoroidSDF(islandPos,
                float3(id) * cellSize + origin, 60+20*snoise(islandPositions[i].xyz), 20,10, randomOffset));
            break;
        }
    }
    
    value = SDFParabolaNormalize(value,isoLevel);
    
    outputPoints[GetPointIndex(id.x, id.y, id.z, dotFieldSize)] = float4(float3(id) * cellSize, value);
    if(value< isoLevel)
    {
        InterlockedAdd(isConcreteFlagBuffer[0],-1);
    }
    else
    {
        InterlockedAdd(isAirFlagBuffer[0],-1);
    }
}
